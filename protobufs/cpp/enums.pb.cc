// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: enums.proto

#include "enums.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)

namespace CARTA {
}  // namespace CARTA
namespace protobuf_enums_2eproto {
void InitDefaults() {
}

const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[23];
const ::google::protobuf::uint32 TableStruct::offsets[1] = {};
static const ::google::protobuf::internal::MigrationSchema* schemas = NULL;
static const ::google::protobuf::Message* const* file_default_instances = NULL;

void protobuf_AssignDescriptors() {
  AddDescriptors();
  AssignDescriptors(
      "enums.proto", schemas, file_default_instances, TableStruct::offsets,
      NULL, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_PROTOBUF_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
}

void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
      "\n\013enums.proto\022\005CARTA*\353\014\n\tEventType\022\017\n\013EM"
      "PTY_EVENT\020\000\022\023\n\017REGISTER_VIEWER\020\001\022\025\n\021FILE"
      "_LIST_REQUEST\020\002\022\025\n\021FILE_INFO_REQUEST\020\003\022\r"
      "\n\tOPEN_FILE\020\004\022\026\n\022SET_IMAGE_CHANNELS\020\006\022\016\n"
      "\nSET_CURSOR\020\007\022\034\n\030SET_SPATIAL_REQUIREMENT"
      "S\020\010\022\036\n\032SET_HISTOGRAM_REQUIREMENTS\020\t\022\032\n\026S"
      "ET_STATS_REQUIREMENTS\020\n\022\016\n\nSET_REGION\020\013\022"
      "\021\n\rREMOVE_REGION\020\014\022\016\n\nCLOSE_FILE\020\r\022\035\n\031SE"
      "T_SPECTRAL_REQUIREMENTS\020\016\022\023\n\017START_ANIMA"
      "TION\020\017\022\027\n\023START_ANIMATION_ACK\020\020\022\022\n\016STOP_"
      "ANIMATION\020\021\022\027\n\023REGISTER_VIEWER_ACK\020\022\022\026\n\022"
      "FILE_LIST_RESPONSE\020\023\022\026\n\022FILE_INFO_RESPON"
      "SE\020\024\022\021\n\rOPEN_FILE_ACK\020\025\022\022\n\016SET_REGION_AC"
      "K\020\026\022\031\n\025REGION_HISTOGRAM_DATA\020\027\022\030\n\024SPATIA"
      "L_PROFILE_DATA\020\031\022\031\n\025SPECTRAL_PROFILE_DAT"
      "A\020\032\022\025\n\021REGION_STATS_DATA\020\033\022\016\n\nERROR_DATA"
      "\020\034\022\032\n\026ANIMATION_FLOW_CONTROL\020\035\022\026\n\022ADD_RE"
      "QUIRED_TILES\020\036\022\031\n\025REMOVE_REQUIRED_TILES\020"
      "\037\022\024\n\020RASTER_TILE_DATA\020 \022\027\n\023REGION_LIST_R"
      "EQUEST\020!\022\030\n\024REGION_LIST_RESPONSE\020\"\022\034\n\030RE"
      "GION_FILE_INFO_REQUEST\020#\022\035\n\031REGION_FILE_"
      "INFO_RESPONSE\020$\022\021\n\rIMPORT_REGION\020%\022\025\n\021IM"
      "PORT_REGION_ACK\020&\022\021\n\rEXPORT_REGION\020\'\022\025\n\021"
      "EXPORT_REGION_ACK\020(\022\032\n\026SET_CONTOUR_PARAM"
      "ETERS\020-\022\026\n\022CONTOUR_IMAGE_DATA\020.\022\022\n\016RESUM"
      "E_SESSION\020/\022\026\n\022RESUME_SESSION_ACK\0200\022\024\n\020R"
      "ASTER_TILE_SYNC\0201\022\030\n\024CATALOG_LIST_REQUES"
      "T\0202\022\031\n\025CATALOG_LIST_RESPONSE\0203\022\035\n\031CATALO"
      "G_FILE_INFO_REQUEST\0204\022\036\n\032CATALOG_FILE_IN"
      "FO_RESPONSE\0205\022\025\n\021OPEN_CATALOG_FILE\0206\022\031\n\025"
      "OPEN_CATALOG_FILE_ACK\0207\022\026\n\022CLOSE_CATALOG"
      "_FILE\0208\022\032\n\026CATALOG_FILTER_REQUEST\0209\022\033\n\027C"
      "ATALOG_FILTER_RESPONSE\020:\022\025\n\021SCRIPTING_RE"
      "QUEST\020;\022\026\n\022SCRIPTING_RESPONSE\020<\022\022\n\016MOMEN"
      "T_REQUEST\020=\022\023\n\017MOMENT_RESPONSE\020>\022\023\n\017MOME"
      "NT_PROGRESS\020\?\022\024\n\020STOP_MOMENT_CALC\020@\022\r\n\tS"
      "AVE_FILE\020A\022\021\n\rSAVE_FILE_ACK\020B\022\031\n\025SPECTRA"
      "L_LINE_REQUEST\020C\022\032\n\026SPECTRAL_LINE_RESPON"
      "SE\020D\022\027\n\023CONCAT_STOKES_FILES\020E\022\033\n\027CONCAT_"
      "STOKES_FILES_ACK\020F\022\026\n\022FILE_LIST_PROGRESS"
      "\020G\022\022\n\016STOP_FILE_LIST\020H\022\024\n\020SPLATALOGUE_PI"
      "NG\020I\022\024\n\020SPLATALOGUE_PONG\020J*#\n\013SessionTyp"
      "e\022\007\n\003NEW\020\000\022\013\n\007RESUMED\020\001*X\n\010FileType\022\010\n\004C"
      "ASA\020\000\022\010\n\004CRTF\020\001\022\013\n\007DS9_REG\020\002\022\010\n\004FITS\020\003\022\010"
      "\n\004HDF5\020\004\022\n\n\006MIRIAD\020\005\022\013\n\007UNKNOWN\020\006*%\n\nRen"
      "derMode\022\n\n\006RASTER\020\000\022\013\n\007CONTOUR\020\001*,\n\017Comp"
      "ressionType\022\010\n\004NONE\020\000\022\007\n\003ZFP\020\001\022\006\n\002SZ\020\002*e"
      "\n\nRegionType\022\t\n\005POINT\020\000\022\010\n\004LINE\020\001\022\014\n\010POL"
      "YLINE\020\002\022\r\n\tRECTANGLE\020\003\022\013\n\007ELLIPSE\020\004\022\013\n\007A"
      "NNULUS\020\005\022\013\n\007POLYGON\020\006*D\n\rSmoothingMode\022\017"
      "\n\013NoSmoothing\020\000\022\020\n\014BlockAverage\020\001\022\020\n\014Gau"
      "ssianBlur\020\002*\342\001\n\tStatsType\022\r\n\tNumPixels\020\000"
      "\022\014\n\010NanCount\020\001\022\007\n\003Sum\020\002\022\017\n\013FluxDensity\020\003"
      "\022\010\n\004Mean\020\004\022\007\n\003RMS\020\005\022\t\n\005Sigma\020\006\022\t\n\005SumSq\020"
      "\007\022\007\n\003Min\020\010\022\007\n\003Max\020\t\022\013\n\007Extrema\020\n\022\007\n\003Blc\020"
      "\013\022\007\n\003Trc\020\014\022\n\n\006MinPos\020\r\022\n\n\006MaxPos\020\016\022\010\n\004Bl"
      "cf\020\017\022\010\n\004Trcf\020\020\022\013\n\007MinPosf\020\021\022\013\n\007MaxPosf\020\022"
      "*J\n\rErrorSeverity\022\t\n\005DEBUG\020\000\022\010\n\004INFO\020\001\022\013"
      "\n\007WARNING\020\002\022\t\n\005ERROR\020\003\022\014\n\010CRITICAL\020\004*+\n\t"
      "EntryType\022\n\n\006STRING\020\000\022\t\n\005FLOAT\020\001\022\007\n\003INT\020"
      "\002*\211\001\n\022ClientFeatureFlags\022\027\n\023CLIENT_FEATU"
      "RE_NONE\020\000\022\n\n\006WEB_GL\020\001\022\014\n\010WEB_GL_2\020\002\022\020\n\014W"
      "EB_ASSEMBLY\020\004\022\030\n\024WEB_ASSEMBLY_THREADS\020\010\022"
      "\024\n\020OFFSCREEN_CANVAS\020\020*\271\001\n\022ServerFeatureF"
      "lags\022\027\n\023SERVER_FEATURE_NONE\020\000\022\022\n\016SZ_COMP"
      "RESSION\020\001\022\024\n\020HEVC_COMPRESSION\020\002\022\025\n\021NVENC"
      "_COMPRESSION\020\004\022\r\n\tREAD_ONLY\020\010\022\024\n\020USER_PR"
      "EFERENCES\020\020\022\020\n\014USER_LAYOUTS\020 \022\022\n\016GRPC_SC"
      "RIPTING\020@*\237\001\n\020FileFeatureFlags\022\025\n\021FILE_F"
      "EATURE_NONE\020\000\022\023\n\017ROTATED_DATASET\020\001\022\026\n\022CH"
      "ANNEL_HISTOGRAMS\020\002\022\023\n\017CUBE_HISTOGRAMS\020\004\022"
      "\021\n\rCHANNEL_STATS\020\010\022\016\n\nMEAN_IMAGE\020\020\022\017\n\013MI"
      "P_DATASET\020 *&\n\016CoordinateType\022\t\n\005PIXEL\020\000"
      "\022\t\n\005WORLD\020\001*-\n\017CatalogFileType\022\r\n\tFITSTa"
      "ble\020\000\022\013\n\007VOTable\020\001*\250\001\n\nColumnType\022\023\n\017Uns"
      "upportedType\020\000\022\n\n\006String\020\001\022\t\n\005Uint8\020\002\022\010\n"
      "\004Int8\020\003\022\n\n\006Uint16\020\004\022\t\n\005Int16\020\005\022\n\n\006Uint32"
      "\020\006\022\t\n\005Int32\020\007\022\n\n\006Uint64\020\010\022\t\n\005Int64\020\t\022\t\n\005"
      "Float\020\n\022\n\n\006Double\020\013\022\010\n\004Bool\020\014*\215\001\n\022Compar"
      "isonOperator\022\t\n\005Equal\020\000\022\014\n\010NotEqual\020\001\022\n\n"
      "\006Lesser\020\002\022\013\n\007Greater\020\003\022\021\n\rLessorOrEqual\020"
      "\004\022\022\n\016GreaterOrEqual\020\005\022\r\n\tRangeOpen\020\006\022\017\n\013"
      "RangeClosed\020\007*,\n\013SortingType\022\r\n\tAscendin"
      "g\020\000\022\016\n\nDescending\020\001*\252\003\n\006Moment\022\030\n\024MEAN_O"
      "F_THE_SPECTRUM\020\000\022\036\n\032INTEGRATED_OF_THE_SP"
      "ECTRUM\020\001\022\034\n\030INTENSITY_WEIGHTED_COORD\020\002\022."
      "\n*INTENSITY_WEIGHTED_DISPERSION_OF_THE_C"
      "OORD\020\003\022\032\n\026MEDIAN_OF_THE_SPECTRUM\020\004\022\025\n\021ME"
      "DIAN_COORDINATE\020\005\022&\n\"STD_ABOUT_THE_MEAN_"
      "OF_THE_SPECTRUM\020\006\022\027\n\023RMS_OF_THE_SPECTRUM"
      "\020\007\022&\n\"ABS_MEAN_DEVIATION_OF_THE_SPECTRUM"
      "\020\010\022\027\n\023MAX_OF_THE_SPECTRUM\020\t\022$\n COORD_OF_"
      "THE_MAX_OF_THE_SPECTRUM\020\n\022\027\n\023MIN_OF_THE_"
      "SPECTRUM\020\013\022$\n COORD_OF_THE_MIN_OF_THE_SP"
      "ECTRUM\020\014*&\n\nMomentAxis\022\014\n\010SPECTRAL\020\000\022\n\n\006"
      "STOKES\020\001*0\n\nMomentMask\022\010\n\004None\020\000\022\013\n\007Incl"
      "ude\020\001\022\013\n\007Exclude\020\002*>\n\nStokesType\022\024\n\020STOK"
      "ES_TYPE_NONE\020\000\022\005\n\001I\020\001\022\005\n\001Q\020\002\022\005\n\001U\020\003\022\005\n\001V"
      "\020\004*&\n\014FileListType\022\t\n\005Image\020\000\022\013\n\007Catalog"
      "\020\001b\006proto3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 3970);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "enums.proto", &protobuf_RegisterTypes);
}

void AddDescriptors() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at dynamic initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
}  // namespace protobuf_enums_2eproto
namespace CARTA {
const ::google::protobuf::EnumDescriptor* EventType_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[0];
}
bool EventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* SessionType_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[1];
}
bool SessionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* FileType_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[2];
}
bool FileType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RenderMode_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[3];
}
bool RenderMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CompressionType_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[4];
}
bool CompressionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RegionType_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[5];
}
bool RegionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* SmoothingMode_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[6];
}
bool SmoothingMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* StatsType_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[7];
}
bool StatsType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ErrorSeverity_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[8];
}
bool ErrorSeverity_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EntryType_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[9];
}
bool EntryType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ClientFeatureFlags_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[10];
}
bool ClientFeatureFlags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ServerFeatureFlags_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[11];
}
bool ServerFeatureFlags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* FileFeatureFlags_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[12];
}
bool FileFeatureFlags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CoordinateType_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[13];
}
bool CoordinateType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CatalogFileType_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[14];
}
bool CatalogFileType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ColumnType_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[15];
}
bool ColumnType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ComparisonOperator_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[16];
}
bool ComparisonOperator_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* SortingType_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[17];
}
bool SortingType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* Moment_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[18];
}
bool Moment_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* MomentAxis_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[19];
}
bool MomentAxis_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* MomentMask_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[20];
}
bool MomentMask_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* StokesType_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[21];
}
bool StokesType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* FileListType_descriptor() {
  protobuf_enums_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_enums_2eproto::file_level_enum_descriptors[22];
}
bool FileListType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace CARTA
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
